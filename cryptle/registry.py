from cryptle.event import source, on

class Registry:
    '''Registry class keeps record of the various important state information for the Strategy
    class. Registry is also responsible for dispatching Events that signifiy the execution of logical tests
    at desired time and frequency as time elapsed.

    Args:
        setup (Dictionary): {'actionname': [[when to execute], {constraints after triggered}]}

    Registry would dictate when these logical tests execute. The logical tests of the Strategy class
    should only execute when they receive their corresponding "registry:test_name" signals. Signals
    are "triggered" if their test return True. In this situation, triggered tests should generate a
    "strategy:triggered" event with its name (in string) as the associated value.

    '''
    def __init__(self, setup):
        #setup in conventional form - see test_registry.py for reference
        self.setup = setup
        # in plain dictionary form, holds all logical states for limiting further triggering of
        self.logic_status = {key: {} for key in setup.keys()}

        # bar-related states that should be sourced from aggregator
        self.bars = []
        self.open_price = None
        self.close_price = None
        self.num_bars = 0
        self.new_open = False
        self.new_close = False
        # tick-related states that should be sourced from feed
        self.current_price = None
        self.current_time = None
        # trade-related states that should be sourced from OrderBook (or equivalent)
        self.buy_count = 0
        self.sell_count = 0
        self.lookup_check   = {'open': self.new_open,
                               'close': self.new_close,}
        # key-value pair with class method as value to predefined name of contraints
        self.lookup_trigger = {'once per bar': self.once_per_bar,
                               'once per trade': self.once_per_trade,
                               'once per period': self.once_per_period,
                               'once per signal': self.once_per_signal,
                               'n per bar': self.n_per_bar,
                               'n per period': self.n_per_period,
                               'n per trade': self.n_per_trade,
                               'n per signal': self.n_per_signal}

    # refresh methods to maintain correct states
    @on('tick') # tick should be fairly agnostic to sources, but should take predefined format
    def refreshTick(self, tick):
        self.new_open = False
        self.new_close = False
        self.lookup_check   = {'open': self.new_open,
                               'close': self.new_close,}
        self.current_price = tick[0]
        self.current_time = tick[2]

    @on('aggregator:new_open') # 'open', 'close' events should be generated by aggregator
    def refreshOpen(self, price):
        self.new_open = True
        self.lookup_check   = {'open': self.new_open,
                               'close': self.new_close,}
        self.open_price = price

    @on('aggregator:new_close')
    def refreshClose(self, price):
        self.close_price = price
        self.new_close = True
        self.lookup_check   = {'open': self.new_open,
                               'close': self.new_close,}

    # these flags are still largely imaginary and are not tested
    @on('buy') # 'buy', 'sell' events are not integrated for the moment
    def refreshBuy(self):
        self.buy_count += 1

    # these flags are still largely imaginary and are not tested
    @on('sell') # 'buy', 'sell' events are not integrated for the moment
    def refreshSell(self):
        self.sell_count += 1

    @on('aggregator:new_candle')
    def refreshCandle(self, bar):
        self.num_bars += 1
        self.bars.append(bar)
        # this calls handleLogicStatus, which would remove all the 'once per bar' and 'n per bar' constraint for every candle
        for key in self.logic_status.keys():
            self.handleLogicStatus(key, 'candle')

        if len(self.bars) > 1000:
            self.bars = self.bars[-1000:]

    @on('aggregator:new_candle')
    def refreshPeriod(self, bar):
        # refreshPeriod should maintain logical states of all period-related constraints
        timeToRefresh = False
        for key in self.logic_status.keys():
            if 'period' not in self.logic_status[key]:
                continue
            elif 'period' in self.logic_status[key]:
                activated_time = self.logic_status[key]['period'][2]
                period         = self.logic_status[key]['period'][1]
                if self.num_bars - activated_time >= period:
                    timeToRefresh = True
            if timeToRefresh:
                self.handleLogicStatus(key, 'period')

    @on('signal') # 'signal' event could be any arbirtary flags, not standardized at the moment
    def refreshSignal(self, signal):
        # refreshSignal should maintain logical states of all signal-related constraints
        signalToRefresh = False
        applyConstraint = False
        signalname, boolean = signal
        # Semi-hardcoded behaviour, hierachy structure to be implemented
        for key in self.logic_status.keys():
            if signalname in self.logic_status[key]:
                # call refreshLogicStatus if signal returned false
                if not boolean and self.logic_status[key][signalname][0] != -1:
                    signalToRefresh = True
                if boolean and self.logic_status[key][signalname][0] == -1:
                    applyConstraint = True
            # cleanup actions resulting from the actions of refreshing signal
            if signalToRefresh:
                self.handleLogicStatus(key, signalname)
            if applyConstraint:
                dictionary = self.setup[key][1][1]
                item = [k for k,v in dictionary.items() if v[-1] == signalname]
                constraint = self.lookup_trigger[item[-1]]
                constraint(key, *dictionary[item[-1]])


    def handleLogicStatus(self, key, timeEvent):
        # hierachy - bar < period < trade < someshit(s) or < someshit(s) < trade? (or customizable?)
        # in any way, when ambiguous -> always take the most lenient one as the one with lowest # hierachy, bar < period < anythng is not ambiguous

        # for any set of given trigger constraint, the format needs to follow the following
        # specification: a dictionary with a string as key to specify constraint category and a
        # list to specify the permissible number of times to be triggered under that type of
        # category e.g. {'bar': [1, 1], 'period': [2, 3], 'trade': [4, 4], 'signal1': [5, 1], 'signal2':
        # [6, 2]}

        # All constraints would be updated when there is a successful trigger of the test. Whether
        # or not a subsequent trigger is blocked depends on the updated status of the logic status:
        # if the lowest category has no more available chances for triggering but the higher
        # categories still have available chances, then the subsequent trigger within the timeframe
        # of the lowest category is blocked until it is refreshed by the passage of time. If the
        # highest category has no more available chances for triggering, then the test could not be
        # triggered subsequently unless the status of the highest category is refreshed.


        # These codes basically removes the timeEvent from self.logic_status of that key, thereby
        # removing any constraint relevant to that cat
        test = self.logic_status[key]
        if timeEvent == 'candle':
            test = {cat:val for cat, val in test.items() if cat != 'bar'}
            self.logic_status[key] = test
        elif timeEvent == 'period':
            test = {cat:val for cat, val in test.items() if cat != 'period'}
            self.logic_status[key] = test

        # This control flow is ultimate hardcode - any signal or trade event that blocks further execution
        # of client codes would be the only relevant condition, only reversal of that signal/trade
        # event could lead to another execution of client codes. In the future, an explicit hierachy
        # structure should be implemented to clearly state the behaviour instead of relying the
        # constraint functions and refresh functions to achieve a more fine-grained control of the
        # execution of client codes.
        else:
            test = {cat:[-1] + [x for i, x in enumerate(val) if i != 0] for cat, val in test.items() if cat == timeEvent}
            #test = {cat:val for cat, val in test.items() if cat != timeEvent}
            self.logic_status[key] = test

    # emitExecute push execute Event to Bus
    @source('registry:execute')
    def emitExecute(self, key):
        # temporary return format for backtesting purposes
        return [str(key), self.current_time, self.current_price]

    # on arrival of tick, handleCheck calls check and carries out checking
    @on('tick')
    def handleCheck(self, tick):
        for key in self.setup.keys():
            self.check(key, self.setup[key][0])

    # check is responsible to verify the current state against the constraints stored signal, *argsn
    # self.setup, it should also check whether any triggered constraint is currently in
    # place, source a "registry:execute" event when all are triggered
    def check(self, key, whenexec):
        key_constr = self.logic_status[key]
        if (all(self.lookup_check[constraint] for constraint in whenexec) and
                (all(key_constr[constraint][0] > 1 for constraint in key_constr) or (key_constr ==
                    {} ))):
                self.emitExecute(key)

    # handleTrigger handles all the triggered tests and apply suitable constraints via constraint functions
    @on('strategy:triggered')
    def handleTrigger(self, action):
        # for updating constraints in the list of setup[1]
        for item in self.setup[action][1][0]:
            constraint = self.lookup_trigger[item]
            constraint(action)
        # for updating constraints in the dictionary of the setup[1]
        for item in self.setup[action][1][1].keys():
            constraint = self.lookup_trigger[item]
            constraint(action, *self.setup[action][1][1][item])

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def once_per_bar(self, action):
        if 'bar' not in self.logic_status[action].keys():
            self.logic_status[action]['bar'] = [1, 1, self.num_bars]
        else:
            self.logic_status[action]['bar'][0] -= 1

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def n_per_bar(self, action, *args):
        if 'bar' not in self.logic_status[action].keys():
            self.logic_status[action]['bar'] = [*args, 1, self.num_bars]
        else:
            self.logic_status[action]['bar'][0] -= 1

    # think of a suitable data structure for storing the updating of these caches
    def once_per_period(self, action, *args):
        if 'bar' not in self.logic_status[action].keys():
            self.logic_status[action]['period'] = [1, *args, self.num_bars]
        else:
            self.logic_status[action]['period'][0] -=1

    # think of a suitable data structure for storing the updating of these caches
    def n_per_period(self, action, *args):
        if 'period' not in self.logic_status[action].keys():
            self.logic_status[action]['period'] = [*args, self.num_bars]
        else:
            self.logic_status[action]['period'][0] -= 1

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def once_per_trade(self, action):
        if 'period' not in self.logic_status[action].keys():
            self.logic_status[action]['trade'] = [1, 1, self.num_bars]
        else:
            self.logic_status[action]['trade'][0] -= 1

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def n_per_trade(self, action, *args):
        if 'trade' not in self.logic_status[action].keys():
            self.logic_status[action]['trade'] = [*args, 1, self.num_bars]
        else:
            self.logic_status[action]['trade'][0] -= 1

    def once_per_signal(self, action, signal, *args):
        # enter via refreshSignal
        if signal in self.logic_status[action].keys():
            if self.logic_status[action][signal][0] == -1:
                del self.logic_status[action][signal]
            else:
                self.logic_status[action][signal][0] -= 1
        elif signal not in self.logic_status[action].keys():
            self.logic_status[action][signal] = [1, 1, self.num_bars]

    def n_per_signal(self, action, signal, *args):
        if signal not in self.logic_status[action].keys():
            self.logic_status[action][signal] = [*args, 1, self.num_bars]
        else:
            self.logic_status[action][signal][0] -= 1
