from cryptle.event import source, on

class Registry:
    '''Registry class that keeps record of the various important state information for the Strategy
    class. Registry is also responsible for dispatching Events that signifiy the execution of logical tests
    at desired time and frequency as time elapsed.

    Args:
        setup (Dictionary): {'actionname': [[whenexec], {constraints after triggered}]}

    Registry would dictate when these logical tests should execute. The logical tests of the Strategy class
    should only execute when they receive their corresponding "registry:test" signals. Signals
    are "triggered" if their test return True. In this situation, triggered tests should generate a
    "strategy:triggered" event with its name (in string) as the associated value.

    '''
    def __init__(self, setup):
        self.setup = setup
        self.logic_status = {key: [[], {}] for key in setup.keys()} # this holds runtime after triggered
                                                              # states of actions

        # bar-related states that should be source by aggregator
        self.open_price = None
        self.close_price = None
        self.bars = []
        self.num_bars = 0
        self.new_open = False
        self.new_close = False
        # tick-related states that should be sourced by feed
        self.current_price = None
        self.current_time = None
        # trade-related states that should be sourced by orderBook (or equivalent)
        self.buy_count = 0
        self.sell_count = 0
        self.lookup_check   = {'open': self.new_open,
                               'close': self.new_close,}
        self.lookup_trigger = {'once per bar': self.once_per_bar,
                               'once per trade': self.once_per_trade,
                               'n per bar': self.n_per_bar,
                               'n per trade': self.n_per_trade,}

    # refresh Functions to maintain correct states
    @on('tick') # tick should be fairly agnostic to sources, but should hold predefined format
    def refreshTick(self, tick):
        self.new_open = False
        self.new_close = False
        self.current_price = tick[0]
        self.current_time = tick[2]

    @on('open') # 'open', 'close' events should be generated by aggregator
    def refreshOpen(self, price):
        self.new_open = True
        self.num_bars += 1
        self.open_price = price

    @on('close')
    def refreshClose(self, price):
        self.close_price = price
        self.new_close = True

    @on('buy') # 'buy', 'sell' events are not implemented for the moment
    def refreshBuy(self):
        self.buy_count += 1

    @on('sell')
    def refreshSell(self):
        self.sell_count += 1

    @on('aggregator:new_candle')
    def refreshCandle(self, bar):
        self.bars.append(bar)
        # this removes all the 'once per bar' constraint for every action
        for key in self.logic_status.keys():
            once = self.logic_status[key][0]
            multi = self.logic_status[key][1]
            if 'once per bar' in once:
                once.pop(once.index('once per bar'))
            if 'n per bar' in multi.keys():
                del multi['n per bar']
    # emitExecute push execute Event to Bus
    @source('registry:execute')
    def emitExecute(self, key):
        # temporary return format, might be revamped
        return [str(key), self.current_time, self.current_price]

    # on arrival of tick, handleCheck carries out check
    @on('tick')
    def handleCheck(self, tick):
        setup = self.setup
        for key in setup.keys():
            self.check(key, setup[key][0])

    # check is responsible to verify the current state against the constraints stored within
    # self.setup, it should also check whether any triggered constraint is currently in
    # place, source a "registry:execute" event when all are triggered
    def check(self, key, whenexec):
        key_constr = self.logic_status[key]
        if (all(self.lookup_check[constraint] for constraint in whenexec) and
            key_constr[0] == [] and
            all(key_constr[1][constraint] != 0 for constraint in key_constr[1].keys())): # now only works if no constraint is placed
               self.emitExecute(key)

    # This handles all the triggered tests and apply suitable constraints via constraint functions
    @on('strategy:triggered')
    def handleTrigger(self, action):
        for item in self.setup[action][1][0]:
            constraint = self.lookup_trigger[item]
            constraint(action)
        for item in self.setup[action][1][1].keys():
            constraint = self.lookup_trigger[item]
            constraint(action, self.setup[action][1][1][item])

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def once_per_bar(self, action):
        self.logic_status[action][0].append('once per bar')

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def n_per_bar(self, action, n):
        if 'n per bar' not in self.logic_status[action][1]:
            self.logic_status[action][1]['n per bar'] = n
        else:
            self.logic_status[action][1]['n per bar'] -= 1

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def once_per_trade(self, action):
        self.logic_status[action][0].append('once per trade')

    # constraint function after triggering, consider revamping into handleTrigger altogether
    def n_per_trade(self, action, n):
        if 'n per trade' not in self.logic_status[action][1]:
            self.logic_status[action][1]['n per trade'] = n
        else:
            self.logic_status[action][1]['n per trade'] -= 1
