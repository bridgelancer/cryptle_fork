import numpy as np
import math

__doc__ = '''
This module provides pure generic functions that are commonly used calculating
indices and metrics constructed from a list of numbers (often time series).

Currently avaiable functions can be classificed to two types, based on their
argument types and return type.

1.  (list -> list) These are mostly vanilla/naive transformations that use
    particular types of weighting to calculate moving averages.

2.  (list -> list[list])

Users are reminded to take care of the varying length of series returned due to
nature of metrics generated by rolling windows.
'''


def percent_diff(up, low):
    '''Percentage difference between two series of numbers

    Args:
        up: A list of floats
        down: A list of floats, with the same length as up
    '''
    return [((u / l) - 1) * 100 for u, l in zip(up, low)]


def simple_moving_average(series, lookback):
    '''Simple Moving Average'''
    output_len = len(series) - lookback
    output = [np.mean(series[:lookback])]
    for i in range(output_len):
        output.append(output[-1] + (series[i + lookback] - series[i]) / lookback)
    return output


def weighted_moving_average(series, lookback):
    '''Weighted Moving Average'''
    output_len = len(series) - lookback + 1
    weight = [(x + 1) / (lookback * (lookback + 1) / 2) for x in range(lookback)]
    return [sum(s * w for s, w in zip(series[i : i+lookback], weight)) for i in range(output_len)]


def exponential_moving_average(series, lookback):
    '''Exponentail Moving Average'''
    output_len = len(series) - lookback + 1
    weight =  2 / (lookback + 1)
    output = [series[0]]
    for i, val in enumerate(series[1:]):
        output.append(weight * val + (1 - weight) * output[-1])
    return output


def bollinger_width(series, lookback, roll_method=simple_moving_average):
    '''Bollinger Band bandwidth experssed in absolute value'''
    output_len = len(series) - lookback + 1
    mean = roll_method(series, lookback)
    output = []
    for i in range(output_len):
        diff_square = [(x - mean[i]) ** 2 for x in series[i : i+lookback]]
        output.append((sum(diff_square) / lookback) ** 0.5)
    return output


def macd(series, fast, slow, signal, roll_method=weighted_moving_average):
    '''Moving Average Convergence Divergence'''
    fast_ma = roll_method(series, fast)
    slow_ma = roll_method(series, slow)
    fast_ma = fast_ma[slow - fast:]
    diff = [f - s for f, s in zip(fast_ma, slow_ma)]
    diff_ma = roll_method(diff, signal)
    diff = diff[signal-1:]
    return diff, diff_ma


def pelt(series, cost_template, penality=None, K=0):
    '''Pruned Exact Linear Time method

    Args:
        cost: Cost function with

    Returns:
        List of changepoints in the provided data series

    Naming Convention:
        tau: A changepoint (candidate)
        F[t]: Optimal value of cost at time t
        R[t]: Pruned changepoints at time t
        cps: Unpruned changepoints at time t
    '''


    # Prepend series with a dummy entry for easier indexing
    penality = penality or np.log(len(series))
    series = [0] + series
    cost = cost_template(series)

    F = [-penality]
    R = [0]
    cps = [[]]

    for t in range(1, len(series)):
        # Step 1, 2
        # Try introducing changpoint at tau: 0 < tau < t, determine the new
        # minimum cost and the tau changepoint that gave this new cost
        F_buffer = {tau : F[tau] + cost(tau+1, t) + penality for tau in R}
        t_min, F_min =  min(F_buffer.items(), key=lambda k: k[1])
        F.append(F_min)

        # Step 3, 4
        # Record the optimal set of changepoints at point of view of time t
        # Prune the remaining possible changepoints for future T > t
        cps.append(cps[t_min] + [t_min])
        R = [tau for tau in R if (F[tau] + cost(tau+1, t) + K) <= F_min] + [t]

    return cps[-1]


def cost_normal_var(series, mean=0):
    data = np.array(series)
    cumm = np.cumsum((data - mean) ** 2)

    def cost(start, end):
        dist = float(end - start + 1)
        diff = cumm[end] - cumm[start-1]
        return dist * (np.log(2 * np.pi) + np.log(diff/dist) + 1)

    return cost

# wrapper function for numpy difference method
def difference(series, n=1):
    return np.diff(series, n)

